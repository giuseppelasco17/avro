<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenericData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Avro</a> &gt; <a href="index.source.html" class="el_package">org.apache.avro.generic</a> &gt; <span class="el_source">GenericData.java</span></div><h1>GenericData.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.avro.generic;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.AbstractList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;

import org.apache.avro.AvroMissingFieldException;
import org.apache.avro.AvroRuntimeException;
import org.apache.avro.AvroTypeException;
import org.apache.avro.Conversion;
import org.apache.avro.Conversions;
import org.apache.avro.JsonProperties;
import org.apache.avro.LogicalType;
import org.apache.avro.Schema;
import org.apache.avro.Schema.Field;
import org.apache.avro.Schema.Type;
import org.apache.avro.UnresolvedUnionException;
import org.apache.avro.io.BinaryData;
import org.apache.avro.io.BinaryDecoder;
import org.apache.avro.io.BinaryEncoder;
import org.apache.avro.io.DatumReader;
import org.apache.avro.io.DatumWriter;
import org.apache.avro.io.DecoderFactory;
import org.apache.avro.io.EncoderFactory;
import org.apache.avro.io.FastReaderBuilder;
import org.apache.avro.util.Utf8;
import org.apache.avro.util.internal.Accessor;

import com.fasterxml.jackson.databind.JsonNode;

/**
 * Utilities for generic Java data. See {@link GenericRecordBuilder} for a
 * convenient way to build {@link GenericRecord} instances.
 *
 * @see GenericRecordBuilder
 */
public class GenericData {

<span class="fc" id="L69">  private static final GenericData INSTANCE = new GenericData();</span>

  /** Used to specify the Java type for a string schema. */
<span class="nc" id="L72">  public enum StringType {</span>
<span class="nc" id="L73">    CharSequence, String, Utf8</span>
  };

  public static final String STRING_PROP = &quot;avro.java.string&quot;;
  protected static final String STRING_TYPE_STRING = &quot;String&quot;;

  private final ClassLoader classLoader;

  /**
   * Set the Java type to be used when reading this schema. Meaningful only only
   * string schemas and map schemas (for the keys).
   */
  public static void setStringType(Schema s, StringType stringType) {
    // Utf8 is the default and implements CharSequence, so we only need to add
    // a property when the type is String
<span class="nc bnc" id="L88" title="All 2 branches missed.">    if (stringType == StringType.String)</span>
<span class="nc" id="L89">      s.addProp(GenericData.STRING_PROP, GenericData.STRING_TYPE_STRING);</span>
<span class="nc" id="L90">  }</span>

  /** Return the singleton instance. */
  public static GenericData get() {
<span class="nc" id="L94">    return INSTANCE;</span>
  }

  /** For subclasses. Applications normally use {@link GenericData#get()}. */
  public GenericData() {
<span class="fc" id="L99">    this(null);</span>
<span class="fc" id="L100">  }</span>

  /** For subclasses. GenericData does not use a ClassLoader. */
<span class="fc" id="L103">  public GenericData(ClassLoader classLoader) {</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    this.classLoader = (classLoader != null) ? classLoader : getClass().getClassLoader();</span>
<span class="fc" id="L105">  }</span>

  /** Return the class loader that's used (by subclasses). */
  public ClassLoader getClassLoader() {
<span class="nc" id="L109">    return classLoader;</span>
  }

<span class="fc" id="L112">  private Map&lt;String, Conversion&lt;?&gt;&gt; conversions = new HashMap&lt;&gt;();</span>

<span class="fc" id="L114">  private Map&lt;Class&lt;?&gt;, Map&lt;String, Conversion&lt;?&gt;&gt;&gt; conversionsByClass = new IdentityHashMap&lt;&gt;();</span>

  public Collection&lt;Conversion&lt;?&gt;&gt; getConversions() {
<span class="nc" id="L117">    return conversions.values();</span>
  }

  /**
   * Registers the given conversion to be used when reading and writing with this
   * data model.
   *
   * @param conversion a logical type Conversion.
   */
  public void addLogicalTypeConversion(Conversion&lt;?&gt; conversion) {
<span class="nc" id="L127">    conversions.put(conversion.getLogicalTypeName(), conversion);</span>
<span class="nc" id="L128">    Class&lt;?&gt; type = conversion.getConvertedType();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (conversionsByClass.containsKey(type)) {</span>
<span class="nc" id="L130">      conversionsByClass.get(type).put(conversion.getLogicalTypeName(), conversion);</span>
    } else {
<span class="nc" id="L132">      Map&lt;String, Conversion&lt;?&gt;&gt; conversions = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L133">      conversions.put(conversion.getLogicalTypeName(), conversion);</span>
<span class="nc" id="L134">      conversionsByClass.put(type, conversions);</span>
    }
<span class="nc" id="L136">  }</span>

  /**
   * Returns the first conversion found for the given class.
   *
   * @param datumClass a Class
   * @return the first registered conversion for the class, or null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; Conversion&lt;T&gt; getConversionByClass(Class&lt;T&gt; datumClass) {
<span class="nc" id="L146">    Map&lt;String, Conversion&lt;?&gt;&gt; conversions = conversionsByClass.get(datumClass);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (conversions != null) {</span>
<span class="nc" id="L148">      return (Conversion&lt;T&gt;) conversions.values().iterator().next();</span>
    }
<span class="nc" id="L150">    return null;</span>
  }

  /**
   * Returns the conversion for the given class and logical type.
   *
   * @param datumClass  a Class
   * @param logicalType a LogicalType
   * @return the conversion for the class and logical type, or null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; Conversion&lt;T&gt; getConversionByClass(Class&lt;T&gt; datumClass, LogicalType logicalType) {
<span class="nc" id="L162">    Map&lt;String, Conversion&lt;?&gt;&gt; conversions = conversionsByClass.get(datumClass);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (conversions != null) {</span>
<span class="nc" id="L164">      return (Conversion&lt;T&gt;) conversions.get(logicalType.getName());</span>
    }
<span class="nc" id="L166">    return null;</span>
  }

  /**
   * Returns the Conversion for the given logical type.
   *
   * @param logicalType a logical type
   * @return the conversion for the logical type, or null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Conversion&lt;Object&gt; getConversionFor(LogicalType logicalType) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">    if (logicalType == null) {</span>
<span class="nc" id="L178">      return null;</span>
    }
<span class="nc" id="L180">    return (Conversion&lt;Object&gt;) conversions.get(logicalType.getName());</span>
  }

  public static final String FAST_READER_PROP = &quot;org.apache.avro.fastread&quot;;
<span class="fc" id="L184">  private boolean fastReaderEnabled = &quot;true&quot;.equalsIgnoreCase(System.getProperty(FAST_READER_PROP));</span>
<span class="fc" id="L185">  private FastReaderBuilder fastReaderBuilder = null;</span>

  public GenericData setFastReaderEnabled(boolean flag) {
<span class="nc" id="L188">    this.fastReaderEnabled = flag;</span>
<span class="nc" id="L189">    return this;</span>
  }

  public boolean isFastReaderEnabled() {
<span class="nc bnc" id="L193" title="All 4 branches missed.">    return fastReaderEnabled &amp;&amp; FastReaderBuilder.isSupportedData(this);</span>
  }

  public FastReaderBuilder getFastReaderBuilder() {
<span class="nc bnc" id="L197" title="All 2 branches missed.">    if (fastReaderBuilder == null) {</span>
<span class="nc" id="L198">      fastReaderBuilder = new FastReaderBuilder(this);</span>
    }
<span class="nc" id="L200">    return this.fastReaderBuilder;</span>
  }

  /**
   * Default implementation of {@link GenericRecord}. Note that this
   * implementation does not fill in default values for fields if they are not
   * specified; use {@link GenericRecordBuilder} in that case.
   *
   * @see GenericRecordBuilder
   */
  public static class Record implements GenericRecord, Comparable&lt;Record&gt; {
    private final Schema schema;
    private final Object[] values;

<span class="nc" id="L214">    public Record(Schema schema) {</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">      if (schema == null || !Type.RECORD.equals(schema.getType()))</span>
<span class="nc" id="L216">        throw new AvroRuntimeException(&quot;Not a record schema: &quot; + schema);</span>
<span class="nc" id="L217">      this.schema = schema;</span>
<span class="nc" id="L218">      this.values = new Object[schema.getFields().size()];</span>
<span class="nc" id="L219">    }</span>

<span class="nc" id="L221">    public Record(Record other, boolean deepCopy) {</span>
<span class="nc" id="L222">      schema = other.schema;</span>
<span class="nc" id="L223">      values = new Object[schema.getFields().size()];</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">      if (deepCopy) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        for (int ii = 0; ii &lt; values.length; ii++) {</span>
<span class="nc" id="L226">          values[ii] = INSTANCE.deepCopy(schema.getFields().get(ii).schema(), other.values[ii]);</span>
        }
      } else {
<span class="nc" id="L229">        System.arraycopy(other.values, 0, values, 0, other.values.length);</span>
      }
<span class="nc" id="L231">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L235">      return schema;</span>
    }

    @Override
    public void put(String key, Object value) {
<span class="nc" id="L240">      Schema.Field field = schema.getField(key);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L242">        throw new AvroRuntimeException(&quot;Not a valid schema field: &quot; + key);</span>
      }

<span class="nc" id="L245">      values[field.pos()] = value;</span>
<span class="nc" id="L246">    }</span>

    @Override
    public void put(int i, Object v) {
<span class="nc" id="L250">      values[i] = v;</span>
<span class="nc" id="L251">    }</span>

    @Override
    public Object get(String key) {
<span class="nc" id="L255">      Field field = schema.getField(key);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L257">        throw new AvroRuntimeException(&quot;Not a valid schema field: &quot; + key);</span>
      }
<span class="nc" id="L259">      return values[field.pos()];</span>
    }

    @Override
    public Object get(int i) {
<span class="nc" id="L264">      return values[i];</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">      if (o == this)</span>
<span class="nc" id="L270">        return true; // identical object</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (!(o instanceof Record))</span>
<span class="nc" id="L272">        return false; // not a record</span>
<span class="nc" id="L273">      Record that = (Record) o;</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">      if (!this.schema.equals(that.schema))</span>
<span class="nc" id="L275">        return false; // not the same schema</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">      return GenericData.get().compare(this, that, schema, true) == 0;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L281">      return GenericData.get().hashCode(this, schema);</span>
    }

    @Override
    public int compareTo(Record that) {
<span class="nc" id="L286">      return GenericData.get().compare(this, that, schema);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L291">      return GenericData.get().toString(this);</span>
    }
  }

  /** Default implementation of an array. */
  @SuppressWarnings(value = &quot;unchecked&quot;)
  public static class Array&lt;T&gt; extends AbstractList&lt;T&gt; implements GenericArray&lt;T&gt;, Comparable&lt;GenericArray&lt;T&gt;&gt; {
<span class="nc" id="L298">    private static final Object[] EMPTY = new Object[0];</span>
    private final Schema schema;
    private int size;
<span class="nc" id="L301">    private Object[] elements = EMPTY;</span>

<span class="nc" id="L303">    public Array(int capacity, Schema schema) {</span>
<span class="nc bnc" id="L304" title="All 4 branches missed.">      if (schema == null || !Type.ARRAY.equals(schema.getType()))</span>
<span class="nc" id="L305">        throw new AvroRuntimeException(&quot;Not an array schema: &quot; + schema);</span>
<span class="nc" id="L306">      this.schema = schema;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      if (capacity != 0)</span>
<span class="nc" id="L308">        elements = new Object[capacity];</span>
<span class="nc" id="L309">    }</span>

<span class="nc" id="L311">    public Array(Schema schema, Collection&lt;T&gt; c) {</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">      if (schema == null || !Type.ARRAY.equals(schema.getType()))</span>
<span class="nc" id="L313">        throw new AvroRuntimeException(&quot;Not an array schema: &quot; + schema);</span>
<span class="nc" id="L314">      this.schema = schema;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">      if (c != null) {</span>
<span class="nc" id="L316">        elements = new Object[c.size()];</span>
<span class="nc" id="L317">        addAll(c);</span>
      }
<span class="nc" id="L319">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L323">      return schema;</span>
    }

    @Override
    public int size() {
<span class="nc" id="L328">      return size;</span>
    }

    @Override
    public void clear() {
      // Let GC do its work
<span class="nc" id="L334">      Arrays.fill(elements, 0, size, null);</span>
<span class="nc" id="L335">      size = 0;</span>
<span class="nc" id="L336">    }</span>

    @Override
    public void reset() {
<span class="nc" id="L340">      size = 0;</span>
<span class="nc" id="L341">    }</span>

    @Override
    public void prune() {
<span class="nc bnc" id="L345" title="All 2 branches missed.">      if (size &lt; elements.length) {</span>
<span class="nc" id="L346">        Arrays.fill(elements, size, elements.length, null);</span>
      }
<span class="nc" id="L348">    }</span>

    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="nc" id="L352">      return new Iterator&lt;T&gt;() {</span>
<span class="nc" id="L353">        private int position = 0;</span>

        @Override
        public boolean hasNext() {
<span class="nc bnc" id="L357" title="All 2 branches missed.">          return position &lt; size;</span>
        }

        @Override
        public T next() {
<span class="nc" id="L362">          return (T) elements[position++];</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L367">          throw new UnsupportedOperationException();</span>
        }
      };
    }

    @Override
    public T get(int i) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">      if (i &gt;= size)</span>
<span class="nc" id="L375">        throw new IndexOutOfBoundsException(&quot;Index &quot; + i + &quot; out of bounds.&quot;);</span>
<span class="nc" id="L376">      return (T) elements[i];</span>
    }

    @Override
    public void add(int location, T o) {
<span class="nc bnc" id="L381" title="All 4 branches missed.">      if (location &gt; size || location &lt; 0) {</span>
<span class="nc" id="L382">        throw new IndexOutOfBoundsException(&quot;Index &quot; + location + &quot; out of bounds.&quot;);</span>
      }
<span class="nc bnc" id="L384" title="All 2 branches missed.">      if (size == elements.length) {</span>
        // Increase size by 1.5x + 1
<span class="nc" id="L386">        final int newSize = size + (size &gt;&gt; 1) + 1;</span>
<span class="nc" id="L387">        elements = Arrays.copyOf(elements, newSize);</span>
      }
<span class="nc" id="L389">      System.arraycopy(elements, location, elements, location + 1, size - location);</span>
<span class="nc" id="L390">      elements[location] = o;</span>
<span class="nc" id="L391">      size++;</span>
<span class="nc" id="L392">    }</span>

    @Override
    public T set(int i, T o) {
<span class="nc bnc" id="L396" title="All 2 branches missed.">      if (i &gt;= size)</span>
<span class="nc" id="L397">        throw new IndexOutOfBoundsException(&quot;Index &quot; + i + &quot; out of bounds.&quot;);</span>
<span class="nc" id="L398">      T response = (T) elements[i];</span>
<span class="nc" id="L399">      elements[i] = o;</span>
<span class="nc" id="L400">      return response;</span>
    }

    @Override
    public T remove(int i) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">      if (i &gt;= size)</span>
<span class="nc" id="L406">        throw new IndexOutOfBoundsException(&quot;Index &quot; + i + &quot; out of bounds.&quot;);</span>
<span class="nc" id="L407">      T result = (T) elements[i];</span>
<span class="nc" id="L408">      --size;</span>
<span class="nc" id="L409">      System.arraycopy(elements, i + 1, elements, i, (size - i));</span>
<span class="nc" id="L410">      elements[size] = null;</span>
<span class="nc" id="L411">      return result;</span>
    }

    @Override
    public T peek() {
<span class="nc bnc" id="L416" title="All 2 branches missed.">      return (size &lt; elements.length) ? (T) elements[size] : null;</span>
    }

    @Override
    public int compareTo(GenericArray&lt;T&gt; that) {
<span class="nc" id="L421">      return GenericData.get().compare(this, that, this.getSchema());</span>
    }

    @Override
    public void reverse() {
<span class="nc" id="L426">      int left = 0;</span>
<span class="nc" id="L427">      int right = elements.length - 1;</span>

<span class="nc bnc" id="L429" title="All 2 branches missed.">      while (left &lt; right) {</span>
<span class="nc" id="L430">        Object tmp = elements[left];</span>
<span class="nc" id="L431">        elements[left] = elements[right];</span>
<span class="nc" id="L432">        elements[right] = tmp;</span>

<span class="nc" id="L434">        left++;</span>
<span class="nc" id="L435">        right--;</span>
<span class="nc" id="L436">      }</span>
<span class="nc" id="L437">    }</span>
  }

  /** Default implementation of {@link GenericFixed}. */
  public static class Fixed implements GenericFixed, Comparable&lt;Fixed&gt; {
    private Schema schema;
    private byte[] bytes;

<span class="nc" id="L445">    public Fixed(Schema schema) {</span>
<span class="nc" id="L446">      setSchema(schema);</span>
<span class="nc" id="L447">    }</span>

<span class="nc" id="L449">    public Fixed(Schema schema, byte[] bytes) {</span>
<span class="nc" id="L450">      this.schema = schema;</span>
<span class="nc" id="L451">      this.bytes = bytes;</span>
<span class="nc" id="L452">    }</span>

<span class="nc" id="L454">    protected Fixed() {</span>
<span class="nc" id="L455">    }</span>

    protected void setSchema(Schema schema) {
<span class="nc" id="L458">      this.schema = schema;</span>
<span class="nc" id="L459">      this.bytes = new byte[schema.getFixedSize()];</span>
<span class="nc" id="L460">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L464">      return schema;</span>
    }

    public void bytes(byte[] bytes) {
<span class="nc" id="L468">      this.bytes = bytes;</span>
<span class="nc" id="L469">    }</span>

    @Override
    public byte[] bytes() {
<span class="nc" id="L473">      return bytes;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L478" title="All 2 branches missed.">      if (o == this)</span>
<span class="nc" id="L479">        return true;</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">      return o instanceof GenericFixed &amp;&amp; Arrays.equals(bytes, ((GenericFixed) o).bytes());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L485">      return Arrays.hashCode(bytes);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L490">      return Arrays.toString(bytes);</span>
    }

    @Override
    public int compareTo(Fixed that) {
<span class="nc" id="L495">      return BinaryData.compareBytes(this.bytes, 0, this.bytes.length, that.bytes, 0, that.bytes.length);</span>
    }
  }

  /** Default implementation of {@link GenericEnumSymbol}. */
  public static class EnumSymbol implements GenericEnumSymbol&lt;EnumSymbol&gt; {
    private Schema schema;
    private String symbol;

<span class="nc" id="L504">    public EnumSymbol(Schema schema, String symbol) {</span>
<span class="nc" id="L505">      this.schema = schema;</span>
<span class="nc" id="L506">      this.symbol = symbol;</span>
<span class="nc" id="L507">    }</span>

    /**
     * Maps existing Objects into an Avro enum by calling toString(), eg for Java
     * Enums
     */
    public EnumSymbol(Schema schema, Object symbol) {
<span class="nc" id="L514">      this(schema, symbol.toString());</span>
<span class="nc" id="L515">    }</span>

    @Override
    public Schema getSchema() {
<span class="nc" id="L519">      return schema;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L524" title="All 2 branches missed.">      if (o == this)</span>
<span class="nc" id="L525">        return true;</span>
<span class="nc bnc" id="L526" title="All 4 branches missed.">      return o instanceof GenericEnumSymbol &amp;&amp; symbol.equals(o.toString());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L531">      return symbol.hashCode();</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L536">      return symbol;</span>
    }

    @Override
    public int compareTo(EnumSymbol that) {
<span class="nc" id="L541">      return GenericData.get().compare(this, that, schema);</span>
    }
  }

  /** Returns a {@link DatumReader} for this kind of data. */
  public DatumReader createDatumReader(Schema schema) {
<span class="nc" id="L547">    return createDatumReader(schema, schema);</span>
  }

  /** Returns a {@link DatumReader} for this kind of data. */
  public DatumReader createDatumReader(Schema writer, Schema reader) {
<span class="nc" id="L552">    return new GenericDatumReader(writer, reader, this);</span>
  }

  /** Returns a {@link DatumWriter} for this kind of data. */
  public DatumWriter createDatumWriter(Schema schema) {
<span class="nc" id="L557">    return new GenericDatumWriter(schema, this);</span>
  }

  /** Returns true if a Java datum matches a schema. */
  public boolean validate(Schema schema, Object datum) {
<span class="nc bnc" id="L562" title="All 15 branches missed.">    switch (schema.getType()) {</span>
    case RECORD:
<span class="nc bnc" id="L564" title="All 2 branches missed.">      if (!isRecord(datum))</span>
<span class="nc" id="L565">        return false;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">      for (Field f : schema.getFields()) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (!validate(f.schema(), getField(datum, f.name(), f.pos())))</span>
<span class="nc" id="L568">          return false;</span>
<span class="nc" id="L569">      }</span>
<span class="nc" id="L570">      return true;</span>
    case ENUM:
<span class="nc bnc" id="L572" title="All 2 branches missed.">      if (!isEnum(datum))</span>
<span class="nc" id="L573">        return false;</span>
<span class="nc" id="L574">      return schema.getEnumSymbols().contains(datum.toString());</span>
    case ARRAY:
<span class="nc bnc" id="L576" title="All 2 branches missed.">      if (!(isArray(datum)))</span>
<span class="nc" id="L577">        return false;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">      for (Object element : getArrayAsCollection(datum))</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (!validate(schema.getElementType(), element))</span>
<span class="nc" id="L580">          return false;</span>
<span class="nc" id="L581">      return true;</span>
    case MAP:
<span class="nc bnc" id="L583" title="All 2 branches missed.">      if (!(isMap(datum)))</span>
<span class="nc" id="L584">        return false;</span>
      @SuppressWarnings(value = &quot;unchecked&quot;)
<span class="nc" id="L586">      Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) datum;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">      for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet())</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (!validate(schema.getValueType(), entry.getValue()))</span>
<span class="nc" id="L589">          return false;</span>
<span class="nc" id="L590">      return true;</span>
    case UNION:
      try {
<span class="nc" id="L593">        int i = resolveUnion(schema, datum);</span>
<span class="nc" id="L594">        return validate(schema.getTypes().get(i), datum);</span>
<span class="nc" id="L595">      } catch (UnresolvedUnionException e) {</span>
<span class="nc" id="L596">        return false;</span>
      }
    case FIXED:
<span class="nc bnc" id="L599" title="All 4 branches missed.">      return datum instanceof GenericFixed &amp;&amp; ((GenericFixed) datum).bytes().length == schema.getFixedSize();</span>
    case STRING:
<span class="nc" id="L601">      return isString(datum);</span>
    case BYTES:
<span class="nc" id="L603">      return isBytes(datum);</span>
    case INT:
<span class="nc" id="L605">      return isInteger(datum);</span>
    case LONG:
<span class="nc" id="L607">      return isLong(datum);</span>
    case FLOAT:
<span class="nc" id="L609">      return isFloat(datum);</span>
    case DOUBLE:
<span class="nc" id="L611">      return isDouble(datum);</span>
    case BOOLEAN:
<span class="nc" id="L613">      return isBoolean(datum);</span>
    case NULL:
<span class="nc bnc" id="L615" title="All 2 branches missed.">      return datum == null;</span>
    default:
<span class="nc" id="L617">      return false;</span>
    }
  }

  /** Renders a Java datum as &lt;a href=&quot;https://www.json.org/&quot;&gt;JSON&lt;/a&gt;. */
  public String toString(Object datum) {
<span class="nc" id="L623">    StringBuilder buffer = new StringBuilder();</span>
<span class="nc" id="L624">    toString(datum, buffer, new IdentityHashMap&lt;&gt;(128));</span>
<span class="nc" id="L625">    return buffer.toString();</span>
  }

  private static final String TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT = &quot; \&quot;&gt;&gt;&gt; CIRCULAR REFERENCE CANNOT BE PUT IN JSON STRING, ABORTING RECURSION &lt;&lt;&lt;\&quot; &quot;;

  /** Renders a Java datum as &lt;a href=&quot;https://www.json.org/&quot;&gt;JSON&lt;/a&gt;. */
  protected void toString(Object datum, StringBuilder buffer, IdentityHashMap&lt;Object, Object&gt; seenObjects) {
<span class="nc bnc" id="L632" title="All 2 branches missed.">    if (isRecord(datum)) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L634">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L635">        return;</span>
      }
<span class="nc" id="L637">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L638">      buffer.append(&quot;{&quot;);</span>
<span class="nc" id="L639">      int count = 0;</span>
<span class="nc" id="L640">      Schema schema = getRecordSchema(datum);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">      for (Field f : schema.getFields()) {</span>
<span class="nc" id="L642">        toString(f.name(), buffer, seenObjects);</span>
<span class="nc" id="L643">        buffer.append(&quot;: &quot;);</span>
<span class="nc" id="L644">        toString(getField(datum, f.name(), f.pos()), buffer, seenObjects);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (++count &lt; schema.getFields().size())</span>
<span class="nc" id="L646">          buffer.append(&quot;, &quot;);</span>
<span class="nc" id="L647">      }</span>
<span class="nc" id="L648">      buffer.append(&quot;}&quot;);</span>
<span class="nc" id="L649">      seenObjects.remove(datum);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">    } else if (isArray(datum)) {</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L652">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L653">        return;</span>
      }
<span class="nc" id="L655">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L656">      Collection&lt;?&gt; array = getArrayAsCollection(datum);</span>
<span class="nc" id="L657">      buffer.append(&quot;[&quot;);</span>
<span class="nc" id="L658">      long last = array.size() - 1;</span>
<span class="nc" id="L659">      int i = 0;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">      for (Object element : array) {</span>
<span class="nc" id="L661">        toString(element, buffer, seenObjects);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (i++ &lt; last)</span>
<span class="nc" id="L663">          buffer.append(&quot;, &quot;);</span>
<span class="nc" id="L664">      }</span>
<span class="nc" id="L665">      buffer.append(&quot;]&quot;);</span>
<span class="nc" id="L666">      seenObjects.remove(datum);</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">    } else if (isMap(datum)) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L669">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L670">        return;</span>
      }
<span class="nc" id="L672">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L673">      buffer.append(&quot;{&quot;);</span>
<span class="nc" id="L674">      int count = 0;</span>
      @SuppressWarnings(value = &quot;unchecked&quot;)
<span class="nc" id="L676">      Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) datum;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">      for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L678">        buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L679">        writeEscapedString(String.valueOf(entry.getKey()), buffer);</span>
<span class="nc" id="L680">        buffer.append(&quot;\&quot;: &quot;);</span>
<span class="nc" id="L681">        toString(entry.getValue(), buffer, seenObjects);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (++count &lt; map.size())</span>
<span class="nc" id="L683">          buffer.append(&quot;, &quot;);</span>
<span class="nc" id="L684">      }</span>
<span class="nc" id="L685">      buffer.append(&quot;}&quot;);</span>
<span class="nc" id="L686">      seenObjects.remove(datum);</span>
<span class="nc bnc" id="L687" title="All 4 branches missed.">    } else if (isString(datum) || isEnum(datum)) {</span>
<span class="nc" id="L688">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L689">      writeEscapedString(datum.toString(), buffer);</span>
<span class="nc" id="L690">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">    } else if (isBytes(datum)) {</span>
<span class="nc" id="L692">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L693">      ByteBuffer bytes = ((ByteBuffer) datum).duplicate();</span>
<span class="nc" id="L694">      writeEscapedString(StandardCharsets.ISO_8859_1.decode(bytes), buffer);</span>
<span class="nc" id="L695">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">    } else if (((datum instanceof Float) &amp;&amp; // quote Nan &amp; Infinity</span>
<span class="nc bnc" id="L697" title="All 6 branches missed.">        (((Float) datum).isInfinite() || ((Float) datum).isNaN()))</span>
<span class="nc bnc" id="L698" title="All 4 branches missed.">        || ((datum instanceof Double) &amp;&amp; (((Double) datum).isInfinite() || ((Double) datum).isNaN()))) {</span>
<span class="nc" id="L699">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L700">      buffer.append(datum);</span>
<span class="nc" id="L701">      buffer.append(&quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">    } else if (datum instanceof GenericData) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">      if (seenObjects.containsKey(datum)) {</span>
<span class="nc" id="L704">        buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);</span>
<span class="nc" id="L705">        return;</span>
      }
<span class="nc" id="L707">      seenObjects.put(datum, datum);</span>
<span class="nc" id="L708">      toString(datum, buffer, seenObjects);</span>
<span class="nc" id="L709">      seenObjects.remove(datum);</span>
    } else {
<span class="nc" id="L711">      buffer.append(datum);</span>
    }
<span class="nc" id="L713">  }</span>

  /* Adapted from https://code.google.com/p/json-simple */
  private static void writeEscapedString(CharSequence string, StringBuilder builder) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">    for (int i = 0; i &lt; string.length(); i++) {</span>
<span class="nc" id="L718">      char ch = string.charAt(i);</span>
<span class="nc bnc" id="L719" title="All 8 branches missed.">      switch (ch) {</span>
      case '&quot;':
<span class="nc" id="L721">        builder.append(&quot;\\\&quot;&quot;);</span>
<span class="nc" id="L722">        break;</span>
      case '\\':
<span class="nc" id="L724">        builder.append(&quot;\\\\&quot;);</span>
<span class="nc" id="L725">        break;</span>
      case '\b':
<span class="nc" id="L727">        builder.append(&quot;\\b&quot;);</span>
<span class="nc" id="L728">        break;</span>
      case '\f':
<span class="nc" id="L730">        builder.append(&quot;\\f&quot;);</span>
<span class="nc" id="L731">        break;</span>
      case '\n':
<span class="nc" id="L733">        builder.append(&quot;\\n&quot;);</span>
<span class="nc" id="L734">        break;</span>
      case '\r':
<span class="nc" id="L736">        builder.append(&quot;\\r&quot;);</span>
<span class="nc" id="L737">        break;</span>
      case '\t':
<span class="nc" id="L739">        builder.append(&quot;\\t&quot;);</span>
<span class="nc" id="L740">        break;</span>
      default:
        // Reference: https://www.unicode.org/versions/Unicode5.1.0/
<span class="nc bnc" id="L743" title="All 12 branches missed.">        if ((ch &gt;= '\u0000' &amp;&amp; ch &lt;= '\u001F') || (ch &gt;= '\u007F' &amp;&amp; ch &lt;= '\u009F')</span>
            || (ch &gt;= '\u2000' &amp;&amp; ch &lt;= '\u20FF')) {
<span class="nc" id="L745">          String hex = Integer.toHexString(ch);</span>
<span class="nc" id="L746">          builder.append(&quot;\\u&quot;);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">          for (int j = 0; j &lt; 4 - hex.length(); j++)</span>
<span class="nc" id="L748">            builder.append('0');</span>
<span class="nc" id="L749">          builder.append(hex.toUpperCase());</span>
<span class="nc" id="L750">        } else {</span>
<span class="nc" id="L751">          builder.append(ch);</span>
        }
      }
    }
<span class="nc" id="L755">  }</span>

  /** Create a schema given an example datum. */
  public Schema induce(Object datum) {
<span class="nc bnc" id="L759" title="All 2 branches missed.">    if (isRecord(datum)) {</span>
<span class="nc" id="L760">      return getRecordSchema(datum);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">    } else if (isArray(datum)) {</span>
<span class="nc" id="L762">      Schema elementType = null;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">      for (Object element : getArrayAsCollection(datum)) {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (elementType == null) {</span>
<span class="nc" id="L765">          elementType = induce(element);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">        } else if (!elementType.equals(induce(element))) {</span>
<span class="nc" id="L767">          throw new AvroTypeException(&quot;No mixed type arrays.&quot;);</span>
        }
<span class="nc" id="L769">      }</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">      if (elementType == null) {</span>
<span class="nc" id="L771">        throw new AvroTypeException(&quot;Empty array: &quot; + datum);</span>
      }
<span class="nc" id="L773">      return Schema.createArray(elementType);</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">    } else if (isMap(datum)) {</span>
      @SuppressWarnings(value = &quot;unchecked&quot;)
<span class="nc" id="L777">      Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) datum;</span>
<span class="nc" id="L778">      Schema value = null;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">      for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet()) {</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L781">          value = induce(entry.getValue());</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        } else if (!value.equals(induce(entry.getValue()))) {</span>
<span class="nc" id="L783">          throw new AvroTypeException(&quot;No mixed type map values.&quot;);</span>
        }
<span class="nc" id="L785">      }</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L787">        throw new AvroTypeException(&quot;Empty map: &quot; + datum);</span>
      }
<span class="nc" id="L789">      return Schema.createMap(value);</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">    } else if (datum instanceof GenericFixed) {</span>
<span class="nc" id="L791">      return Schema.createFixed(null, null, null, ((GenericFixed) datum).bytes().length);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">    } else if (isString(datum))</span>
<span class="nc" id="L793">      return Schema.create(Type.STRING);</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">    else if (isBytes(datum))</span>
<span class="nc" id="L795">      return Schema.create(Type.BYTES);</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">    else if (isInteger(datum))</span>
<span class="nc" id="L797">      return Schema.create(Type.INT);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">    else if (isLong(datum))</span>
<span class="nc" id="L799">      return Schema.create(Type.LONG);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">    else if (isFloat(datum))</span>
<span class="nc" id="L801">      return Schema.create(Type.FLOAT);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">    else if (isDouble(datum))</span>
<span class="nc" id="L803">      return Schema.create(Type.DOUBLE);</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">    else if (isBoolean(datum))</span>
<span class="nc" id="L805">      return Schema.create(Type.BOOLEAN);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">    else if (datum == null)</span>
<span class="nc" id="L807">      return Schema.create(Type.NULL);</span>

    else
<span class="nc" id="L810">      throw new AvroTypeException(&quot;Can't create schema for: &quot; + datum);</span>
  }

  /**
   * Called by {@link GenericDatumReader#readRecord} to set a record fields value
   * to a record instance. The default implementation is for
   * {@link IndexedRecord}.
   */
  public void setField(Object record, String name, int position, Object value) {
<span class="nc" id="L819">    ((IndexedRecord) record).put(position, value);</span>
<span class="nc" id="L820">  }</span>

  /**
   * Called by {@link GenericDatumReader#readRecord} to retrieve a record field
   * value from a reused instance. The default implementation is for
   * {@link IndexedRecord}.
   */
  public Object getField(Object record, String name, int position) {
<span class="nc" id="L828">    return ((IndexedRecord) record).get(position);</span>
  }

  /**
   * Produce state for repeated calls to
   * {@link #getField(Object,String,int,Object)} and
   * {@link #setField(Object,String,int,Object,Object)} on the same record.
   */
  protected Object getRecordState(Object record, Schema schema) {
<span class="nc" id="L837">    return null;</span>
  }

  /** Version of {@link #setField} that has state. */
  protected void setField(Object record, String name, int position, Object value, Object state) {
<span class="nc" id="L842">    setField(record, name, position, value);</span>
<span class="nc" id="L843">  }</span>

  /** Version of {@link #getField} that has state. */
  protected Object getField(Object record, String name, int pos, Object state) {
<span class="nc" id="L847">    return getField(record, name, pos);</span>
  }

  /**
   * Return the index for a datum within a union. Implemented with
   * {@link Schema#getIndexNamed(String)} and {@link #getSchemaName(Object)}.
   */
  public int resolveUnion(Schema union, Object datum) {
    // if there is a logical type that works, use it first
    // this allows logical type concrete classes to overlap with supported ones
    // for example, a conversion could return a map
<span class="nc bnc" id="L858" title="All 2 branches missed.">    if (datum != null) {</span>
<span class="nc" id="L859">      Map&lt;String, Conversion&lt;?&gt;&gt; conversions = conversionsByClass.get(datum.getClass());</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">      if (conversions != null) {</span>
<span class="nc" id="L861">        List&lt;Schema&gt; candidates = union.getTypes();</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">        for (int i = 0; i &lt; candidates.size(); i += 1) {</span>
<span class="nc" id="L863">          LogicalType candidateType = candidates.get(i).getLogicalType();</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">          if (candidateType != null) {</span>
<span class="nc" id="L865">            Conversion&lt;?&gt; conversion = conversions.get(candidateType.getName());</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">            if (conversion != null) {</span>
<span class="nc" id="L867">              return i;</span>
            }
          }
        }
      }
    }

<span class="nc" id="L874">    Integer i = union.getIndexNamed(getSchemaName(datum));</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">    if (i != null) {</span>
<span class="nc" id="L876">      return i;</span>
    }
<span class="nc" id="L878">    throw new UnresolvedUnionException(union, datum);</span>
  }

  /**
   * Return the schema full name for a datum. Called by
   * {@link #resolveUnion(Schema,Object)}.
   */
  protected String getSchemaName(Object datum) {
<span class="nc bnc" id="L886" title="All 4 branches missed.">    if (datum == null || datum == JsonProperties.NULL_VALUE)</span>
<span class="nc" id="L887">      return Type.NULL.getName();</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">    if (isRecord(datum))</span>
<span class="nc" id="L889">      return getRecordSchema(datum).getFullName();</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">    if (isEnum(datum))</span>
<span class="nc" id="L891">      return getEnumSchema(datum).getFullName();</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">    if (isArray(datum))</span>
<span class="nc" id="L893">      return Type.ARRAY.getName();</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">    if (isMap(datum))</span>
<span class="nc" id="L895">      return Type.MAP.getName();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">    if (isFixed(datum))</span>
<span class="nc" id="L897">      return getFixedSchema(datum).getFullName();</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">    if (isString(datum))</span>
<span class="nc" id="L899">      return Type.STRING.getName();</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">    if (isBytes(datum))</span>
<span class="nc" id="L901">      return Type.BYTES.getName();</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">    if (isInteger(datum))</span>
<span class="nc" id="L903">      return Type.INT.getName();</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">    if (isLong(datum))</span>
<span class="nc" id="L905">      return Type.LONG.getName();</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">    if (isFloat(datum))</span>
<span class="nc" id="L907">      return Type.FLOAT.getName();</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">    if (isDouble(datum))</span>
<span class="nc" id="L909">      return Type.DOUBLE.getName();</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">    if (isBoolean(datum))</span>
<span class="nc" id="L911">      return Type.BOOLEAN.getName();</span>
<span class="nc" id="L912">    throw new AvroRuntimeException(String.format(&quot;Unknown datum type %s: %s&quot;, datum.getClass().getName(), datum));</span>
  }

  /**
   * Called by {@link #resolveUnion(Schema,Object)}. May be overridden for
   * alternate data representations.
   */
  protected boolean instanceOf(Schema schema, Object datum) {
<span class="nc bnc" id="L920" title="All 14 branches missed.">    switch (schema.getType()) {</span>
    case RECORD:
<span class="nc bnc" id="L922" title="All 2 branches missed.">      if (!isRecord(datum))</span>
<span class="nc" id="L923">        return false;</span>
<span class="nc bnc" id="L924" title="All 4 branches missed.">      return (schema.getFullName() == null) ? getRecordSchema(datum).getFullName() == null</span>
<span class="nc" id="L925">          : schema.getFullName().equals(getRecordSchema(datum).getFullName());</span>
    case ENUM:
<span class="nc bnc" id="L927" title="All 2 branches missed.">      if (!isEnum(datum))</span>
<span class="nc" id="L928">        return false;</span>
<span class="nc" id="L929">      return schema.getFullName().equals(getEnumSchema(datum).getFullName());</span>
    case ARRAY:
<span class="nc" id="L931">      return isArray(datum);</span>
    case MAP:
<span class="nc" id="L933">      return isMap(datum);</span>
    case FIXED:
<span class="nc bnc" id="L935" title="All 2 branches missed.">      if (!isFixed(datum))</span>
<span class="nc" id="L936">        return false;</span>
<span class="nc" id="L937">      return schema.getFullName().equals(getFixedSchema(datum).getFullName());</span>
    case STRING:
<span class="nc" id="L939">      return isString(datum);</span>
    case BYTES:
<span class="nc" id="L941">      return isBytes(datum);</span>
    case INT:
<span class="nc" id="L943">      return isInteger(datum);</span>
    case LONG:
<span class="nc" id="L945">      return isLong(datum);</span>
    case FLOAT:
<span class="nc" id="L947">      return isFloat(datum);</span>
    case DOUBLE:
<span class="nc" id="L949">      return isDouble(datum);</span>
    case BOOLEAN:
<span class="nc" id="L951">      return isBoolean(datum);</span>
    case NULL:
<span class="nc bnc" id="L953" title="All 2 branches missed.">      return datum == null;</span>
    default:
<span class="nc" id="L955">      throw new AvroRuntimeException(&quot;Unexpected type: &quot; + schema);</span>
    }
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isArray(Object datum) {
<span class="nc" id="L961">    return datum instanceof Collection;</span>
  }

  /** Called to access an array as a collection. */
  protected Collection getArrayAsCollection(Object datum) {
<span class="nc" id="L966">    return (Collection) datum;</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isRecord(Object datum) {
<span class="nc" id="L971">    return datum instanceof IndexedRecord;</span>
  }

  /**
   * Called to obtain the schema of a record. By default calls
   * {GenericContainer#getSchema(). May be overridden for alternate record
   * representations.
   */
  protected Schema getRecordSchema(Object record) {
<span class="nc" id="L980">    return ((GenericContainer) record).getSchema();</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isEnum(Object datum) {
<span class="nc" id="L985">    return datum instanceof GenericEnumSymbol;</span>
  }

  /**
   * Called to obtain the schema of a enum. By default calls
   * {GenericContainer#getSchema(). May be overridden for alternate enum
   * representations.
   */
  protected Schema getEnumSchema(Object enu) {
<span class="nc" id="L994">    return ((GenericContainer) enu).getSchema();</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isMap(Object datum) {
<span class="nc" id="L999">    return datum instanceof Map;</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isFixed(Object datum) {
<span class="nc" id="L1004">    return datum instanceof GenericFixed;</span>
  }

  /**
   * Called to obtain the schema of a fixed. By default calls
   * {GenericContainer#getSchema(). May be overridden for alternate fixed
   * representations.
   */
  protected Schema getFixedSchema(Object fixed) {
<span class="nc" id="L1013">    return ((GenericContainer) fixed).getSchema();</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isString(Object datum) {
<span class="nc" id="L1018">    return datum instanceof CharSequence;</span>
  }

  /** Called by the default implementation of {@link #instanceOf}. */
  protected boolean isBytes(Object datum) {
<span class="nc" id="L1023">    return datum instanceof ByteBuffer;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isInteger(Object datum) {
<span class="nc" id="L1030">    return datum instanceof Integer;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isLong(Object datum) {
<span class="nc" id="L1037">    return datum instanceof Long;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isFloat(Object datum) {
<span class="nc" id="L1044">    return datum instanceof Float;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isDouble(Object datum) {
<span class="nc" id="L1051">    return datum instanceof Double;</span>
  }

  /**
   * Called by the default implementation of {@link #instanceOf}.
   */
  protected boolean isBoolean(Object datum) {
<span class="nc" id="L1058">    return datum instanceof Boolean;</span>
  }

  /**
   * Compute a hash code according to a schema, consistent with
   * {@link #compare(Object,Object,Schema)}.
   */
  public int hashCode(Object o, Schema s) {
<span class="nc bnc" id="L1066" title="All 2 branches missed.">    if (o == null)</span>
<span class="nc" id="L1067">      return 0; // incomplete datum</span>
<span class="nc" id="L1068">    int hashCode = 1;</span>
<span class="nc bnc" id="L1069" title="All 7 branches missed.">    switch (s.getType()) {</span>
    case RECORD:
<span class="nc bnc" id="L1071" title="All 2 branches missed.">      for (Field f : s.getFields()) {</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        if (f.order() == Field.Order.IGNORE)</span>
<span class="nc" id="L1073">          continue;</span>
<span class="nc" id="L1074">        hashCode = hashCodeAdd(hashCode, getField(o, f.name(), f.pos()), f.schema());</span>
<span class="nc" id="L1075">      }</span>
<span class="nc" id="L1076">      return hashCode;</span>
    case ARRAY:
<span class="nc" id="L1078">      Collection&lt;?&gt; a = (Collection&lt;?&gt;) o;</span>
<span class="nc" id="L1079">      Schema elementType = s.getElementType();</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">      for (Object e : a)</span>
<span class="nc" id="L1081">        hashCode = hashCodeAdd(hashCode, e, elementType);</span>
<span class="nc" id="L1082">      return hashCode;</span>
    case UNION:
<span class="nc" id="L1084">      return hashCode(o, s.getTypes().get(resolveUnion(s, o)));</span>
    case ENUM:
<span class="nc" id="L1086">      return s.getEnumOrdinal(o.toString());</span>
    case NULL:
<span class="nc" id="L1088">      return 0;</span>
    case STRING:
<span class="nc bnc" id="L1090" title="All 2 branches missed.">      return (o instanceof Utf8 ? o : new Utf8(o.toString())).hashCode();</span>
    default:
<span class="nc" id="L1092">      return o.hashCode();</span>
    }
  }

  /** Add the hash code for an object into an accumulated hash code. */
  protected int hashCodeAdd(int hashCode, Object o, Schema s) {
<span class="nc" id="L1098">    return 31 * hashCode + hashCode(o, s);</span>
  }

  /**
   * Compare objects according to their schema. If equal, return zero. If
   * greater-than, return 1, if less than return -1. Order is consistent with that
   * of {@link BinaryData#compare(byte[], int, byte[], int, Schema)}.
   */
  public int compare(Object o1, Object o2, Schema s) {
<span class="nc" id="L1107">    return compare(o1, o2, s, false);</span>
  }

  /**
   * Comparison implementation. When equals is true, only checks for equality, not
   * for order.
   */
  @SuppressWarnings(value = &quot;unchecked&quot;)
  protected int compare(Object o1, Object o2, Schema s, boolean equals) {
<span class="nc bnc" id="L1116" title="All 2 branches missed.">    if (o1 == o2)</span>
<span class="nc" id="L1117">      return 0;</span>
<span class="nc bnc" id="L1118" title="All 8 branches missed.">    switch (s.getType()) {</span>
    case RECORD:
<span class="nc bnc" id="L1120" title="All 2 branches missed.">      for (Field f : s.getFields()) {</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (f.order() == Field.Order.IGNORE)</span>
<span class="nc" id="L1122">          continue; // ignore this field</span>
<span class="nc" id="L1123">        int pos = f.pos();</span>
<span class="nc" id="L1124">        String name = f.name();</span>
<span class="nc" id="L1125">        int compare = compare(getField(o1, name, pos), getField(o2, name, pos), f.schema(), equals);</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (compare != 0) // not equal</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">          return f.order() == Field.Order.DESCENDING ? -compare : compare;</span>
<span class="nc" id="L1128">      }</span>
<span class="nc" id="L1129">      return 0;</span>
    case ENUM:
<span class="nc" id="L1131">      return s.getEnumOrdinal(o1.toString()) - s.getEnumOrdinal(o2.toString());</span>
    case ARRAY:
<span class="nc" id="L1133">      Collection a1 = (Collection) o1;</span>
<span class="nc" id="L1134">      Collection a2 = (Collection) o2;</span>
<span class="nc" id="L1135">      Iterator e1 = a1.iterator();</span>
<span class="nc" id="L1136">      Iterator e2 = a2.iterator();</span>
<span class="nc" id="L1137">      Schema elementType = s.getElementType();</span>
<span class="nc bnc" id="L1138" title="All 4 branches missed.">      while (e1.hasNext() &amp;&amp; e2.hasNext()) {</span>
<span class="nc" id="L1139">        int compare = compare(e1.next(), e2.next(), elementType, equals);</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        if (compare != 0)</span>
<span class="nc" id="L1141">          return compare;</span>
<span class="nc" id="L1142">      }</span>
<span class="nc bnc" id="L1143" title="All 4 branches missed.">      return e1.hasNext() ? 1 : (e2.hasNext() ? -1 : 0);</span>
    case MAP:
<span class="nc bnc" id="L1145" title="All 2 branches missed.">      if (equals)</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        return o1.equals(o2) ? 0 : 1;</span>
<span class="nc" id="L1147">      throw new AvroRuntimeException(&quot;Can't compare maps!&quot;);</span>
    case UNION:
<span class="nc" id="L1149">      int i1 = resolveUnion(s, o1);</span>
<span class="nc" id="L1150">      int i2 = resolveUnion(s, o2);</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">      return (i1 == i2) ? compare(o1, o2, s.getTypes().get(i1), equals) : Integer.compare(i1, i2);</span>
    case NULL:
<span class="nc" id="L1153">      return 0;</span>
    case STRING:
<span class="nc bnc" id="L1155" title="All 2 branches missed.">      Utf8 u1 = o1 instanceof Utf8 ? (Utf8) o1 : new Utf8(o1.toString());</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">      Utf8 u2 = o2 instanceof Utf8 ? (Utf8) o2 : new Utf8(o2.toString());</span>
<span class="nc" id="L1157">      return u1.compareTo(u2);</span>
    default:
<span class="nc" id="L1159">      return ((Comparable) o1).compareTo(o2);</span>
    }
  }

<span class="fc" id="L1163">  private final Map&lt;Field, Object&gt; defaultValueCache = Collections.synchronizedMap(new WeakHashMap&lt;&gt;());</span>

  /**
   * Gets the default value of the given field, if any.
   *
   * @param field the field whose default value should be retrieved.
   * @return the default value associated with the given field, or null if none is
   *         specified in the schema.
   */
  @SuppressWarnings({ &quot;unchecked&quot; })
  public Object getDefaultValue(Field field) {
<span class="nc" id="L1174">    JsonNode json = Accessor.defaultValue(field);</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">    if (json == null)</span>
<span class="nc" id="L1176">      throw new AvroMissingFieldException(&quot;Field &quot; + field + &quot; not set and has no default value&quot;, field);</span>
<span class="nc bnc" id="L1177" title="All 4 branches missed.">    if (json.isNull() &amp;&amp; (field.schema().getType() == Type.NULL</span>
<span class="nc bnc" id="L1178" title="All 4 branches missed.">        || (field.schema().getType() == Type.UNION &amp;&amp; field.schema().getTypes().get(0).getType() == Type.NULL))) {</span>
<span class="nc" id="L1179">      return null;</span>
    }

    // Check the cache
<span class="nc" id="L1183">    Object defaultValue = defaultValueCache.get(field);</span>

    // If not cached, get the default Java value by encoding the default JSON
    // value and then decoding it:
<span class="nc bnc" id="L1187" title="All 2 branches missed.">    if (defaultValue == null)</span>
      try {
<span class="nc" id="L1189">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1190">        BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(baos, null);</span>
<span class="nc" id="L1191">        Accessor.encode(encoder, field.schema(), json);</span>
<span class="nc" id="L1192">        encoder.flush();</span>
<span class="nc" id="L1193">        BinaryDecoder decoder = DecoderFactory.get().binaryDecoder(baos.toByteArray(), null);</span>
<span class="nc" id="L1194">        defaultValue = createDatumReader(field.schema()).read(null, decoder);</span>

        // this MAY result in two threads creating the same defaultValue
        // and calling put. The last thread will win. However,
        // that's not an issue.
<span class="nc" id="L1199">        defaultValueCache.put(field, defaultValue);</span>
<span class="nc" id="L1200">      } catch (IOException e) {</span>
<span class="nc" id="L1201">        throw new AvroRuntimeException(e);</span>
<span class="nc" id="L1202">      }</span>

<span class="nc" id="L1204">    return defaultValue;</span>
  }

<span class="fc" id="L1207">  private static final Schema STRINGS = Schema.create(Type.STRING);</span>

  /**
   * Makes a deep copy of a value given its schema.
   * &lt;P&gt;
   * Logical types are converted to raw types, copied, then converted back.
   *
   * @param schema the schema of the value to deep copy.
   * @param value  the value to deep copy.
   * @return a deep copy of the given value.
   */
  @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
  public &lt;T&gt; T deepCopy(Schema schema, T value) {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">    if (value == null)</span>
<span class="nc" id="L1221">      return null;</span>
<span class="nc" id="L1222">    LogicalType logicalType = schema.getLogicalType();</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">    if (logicalType == null) // not a logical type -- use raw copy</span>
<span class="nc" id="L1224">      return (T) deepCopyRaw(schema, value);</span>
<span class="nc" id="L1225">    Conversion conversion = getConversionByClass(value.getClass(), logicalType);</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">    if (conversion == null) // no conversion defined -- try raw copy</span>
<span class="nc" id="L1227">      return (T) deepCopyRaw(schema, value);</span>
    // logical type with conversion: convert to raw, copy, then convert back to
    // logical
<span class="nc" id="L1230">    Object raw = Conversions.convertToRawType(value, schema, logicalType, conversion);</span>
<span class="nc" id="L1231">    Object copy = deepCopyRaw(schema, raw); // copy raw</span>
<span class="nc" id="L1232">    return (T) Conversions.convertToLogicalType(copy, schema, logicalType, conversion);</span>
  }

  private Object deepCopyRaw(Schema schema, Object value) {
<span class="nc bnc" id="L1236" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L1237">      return null;</span>
    }

<span class="nc bnc" id="L1240" title="All 15 branches missed.">    switch (schema.getType()) {</span>
    case ARRAY:
<span class="nc" id="L1242">      List&lt;Object&gt; arrayValue = (List) value;</span>
<span class="nc" id="L1243">      List&lt;Object&gt; arrayCopy = new GenericData.Array&lt;&gt;(arrayValue.size(), schema);</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">      for (Object obj : arrayValue) {</span>
<span class="nc" id="L1245">        arrayCopy.add(deepCopy(schema.getElementType(), obj));</span>
<span class="nc" id="L1246">      }</span>
<span class="nc" id="L1247">      return arrayCopy;</span>
    case BOOLEAN:
<span class="nc" id="L1249">      return value; // immutable</span>
    case BYTES:
<span class="nc" id="L1251">      ByteBuffer byteBufferValue = (ByteBuffer) value;</span>
<span class="nc" id="L1252">      int start = byteBufferValue.position();</span>
<span class="nc" id="L1253">      int length = byteBufferValue.limit() - start;</span>
<span class="nc" id="L1254">      byte[] bytesCopy = new byte[length];</span>
<span class="nc" id="L1255">      byteBufferValue.get(bytesCopy, 0, length);</span>
<span class="nc" id="L1256">      ((Buffer) byteBufferValue).position(start);</span>
<span class="nc" id="L1257">      return ByteBuffer.wrap(bytesCopy, 0, length);</span>
    case DOUBLE:
<span class="nc" id="L1259">      return value; // immutable</span>
    case ENUM:
<span class="nc" id="L1261">      return createEnum(value.toString(), schema);</span>
    case FIXED:
<span class="nc" id="L1263">      return createFixed(null, ((GenericFixed) value).bytes(), schema);</span>
    case FLOAT:
<span class="nc" id="L1265">      return value; // immutable</span>
    case INT:
<span class="nc" id="L1267">      return value; // immutable</span>
    case LONG:
<span class="nc" id="L1269">      return value; // immutable</span>
    case MAP:
<span class="nc" id="L1271">      Map&lt;Object, Object&gt; mapValue = (Map) value;</span>
<span class="nc" id="L1272">      Map&lt;Object, Object&gt; mapCopy = new HashMap&lt;&gt;(mapValue.size());</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">      for (Map.Entry&lt;Object, Object&gt; entry : mapValue.entrySet()) {</span>
<span class="nc" id="L1274">        mapCopy.put(deepCopy(STRINGS, entry.getKey()), deepCopy(schema.getValueType(), entry.getValue()));</span>
<span class="nc" id="L1275">      }</span>
<span class="nc" id="L1276">      return mapCopy;</span>
    case NULL:
<span class="nc" id="L1278">      return null;</span>
    case RECORD:
<span class="nc" id="L1280">      Object oldState = getRecordState(value, schema);</span>
<span class="nc" id="L1281">      Object newRecord = newRecord(null, schema);</span>
<span class="nc" id="L1282">      Object newState = getRecordState(newRecord, schema);</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">      for (Field f : schema.getFields()) {</span>
<span class="nc" id="L1284">        int pos = f.pos();</span>
<span class="nc" id="L1285">        String name = f.name();</span>
<span class="nc" id="L1286">        Object newValue = deepCopy(f.schema(), getField(value, name, pos, oldState));</span>
<span class="nc" id="L1287">        setField(newRecord, name, pos, newValue, newState);</span>
<span class="nc" id="L1288">      }</span>
<span class="nc" id="L1289">      return newRecord;</span>
    case STRING:
<span class="nc" id="L1291">      return createString(value);</span>
    case UNION:
<span class="nc" id="L1293">      return deepCopy(schema.getTypes().get(resolveUnion(schema, value)), value);</span>
    default:
<span class="nc" id="L1295">      throw new AvroRuntimeException(&quot;Deep copy failed for schema \&quot;&quot; + schema + &quot;\&quot; and value \&quot;&quot; + value + &quot;\&quot;&quot;);</span>
    }
  }

  /**
   * Called to create an fixed value. May be overridden for alternate fixed
   * representations. By default, returns {@link GenericFixed}.
   */
  public Object createFixed(Object old, Schema schema) {
<span class="nc bnc" id="L1304" title="All 4 branches missed.">    if ((old instanceof GenericFixed) &amp;&amp; ((GenericFixed) old).bytes().length == schema.getFixedSize())</span>
<span class="nc" id="L1305">      return old;</span>
<span class="nc" id="L1306">    return new GenericData.Fixed(schema);</span>
  }

  /**
   * Called to create an fixed value. May be overridden for alternate fixed
   * representations. By default, returns {@link GenericFixed}.
   */
  public Object createFixed(Object old, byte[] bytes, Schema schema) {
<span class="nc" id="L1314">    GenericFixed fixed = (GenericFixed) createFixed(old, schema);</span>
<span class="nc" id="L1315">    System.arraycopy(bytes, 0, fixed.bytes(), 0, schema.getFixedSize());</span>
<span class="nc" id="L1316">    return fixed;</span>
  }

  /**
   * Called to create an enum value. May be overridden for alternate enum
   * representations. By default, returns a GenericEnumSymbol.
   */
  public Object createEnum(String symbol, Schema schema) {
<span class="nc" id="L1324">    return new EnumSymbol(schema, symbol);</span>
  }

  /**
   * Called to create new record instances. Subclasses may override to use a
   * different record implementation. The returned instance must conform to the
   * schema provided. If the old object contains fields not present in the schema,
   * they should either be removed from the old object, or it should create a new
   * instance that conforms to the schema. By default, this returns a
   * {@link GenericData.Record}.
   */
  public Object newRecord(Object old, Schema schema) {
<span class="nc bnc" id="L1336" title="All 2 branches missed.">    if (old instanceof IndexedRecord) {</span>
<span class="nc" id="L1337">      IndexedRecord record = (IndexedRecord) old;</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">      if (record.getSchema() == schema)</span>
<span class="nc" id="L1339">        return record;</span>
    }
<span class="nc" id="L1341">    return new GenericData.Record(schema);</span>
  }

  /**
   * Called to create an string value. May be overridden for alternate string
   * representations.
   */
  public Object createString(Object value) {
    // Strings are immutable
<span class="nc bnc" id="L1350" title="All 2 branches missed.">    if (value instanceof String) {</span>
<span class="nc" id="L1351">      return value;</span>
    }

    // Some CharSequence subclasses are mutable, so we still need to make
    // a copy
<span class="nc bnc" id="L1356" title="All 2 branches missed.">    else if (value instanceof Utf8) {</span>
      // Utf8 copy constructor is more efficient than converting
      // to string and then back to Utf8
<span class="nc" id="L1359">      return new Utf8((Utf8) value);</span>
    }
<span class="nc" id="L1361">    return new Utf8(value.toString());</span>

  }

  /*
   * Called to create new array instances. Subclasses may override to use a
   * different array implementation. By default, this returns a {@link
   * GenericData.Array}.
   */
  public Object newArray(Object old, int size, Schema schema) {
<span class="nc bnc" id="L1371" title="All 2 branches missed.">    if (old instanceof GenericArray) {</span>
<span class="nc" id="L1372">      ((GenericArray&lt;?&gt;) old).reset();</span>
<span class="nc" id="L1373">      return old;</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">    } else if (old instanceof Collection) {</span>
<span class="nc" id="L1375">      ((Collection&lt;?&gt;) old).clear();</span>
<span class="nc" id="L1376">      return old;</span>
    } else
<span class="nc" id="L1378">      return new GenericData.Array&lt;Object&gt;(size, schema);</span>
  }

  /**
   * Called to create new array instances. Subclasses may override to use a
   * different map implementation. By default, this returns a {@link HashMap}.
   */
  public Object newMap(Object old, int size) {
<span class="nc bnc" id="L1386" title="All 2 branches missed.">    if (old instanceof Map) {</span>
<span class="nc" id="L1387">      ((Map&lt;?, ?&gt;) old).clear();</span>
<span class="nc" id="L1388">      return old;</span>
    } else
<span class="nc" id="L1390">      return new HashMap&lt;&gt;(size);</span>
  }

  /**
   * create a supplier that allows to get new record instances for a given schema
   * in an optimized way
   */
  public InstanceSupplier getNewRecordSupplier(Schema schema) {
<span class="nc" id="L1398">    return this::newRecord;</span>
  }

  public interface InstanceSupplier {
    public Object newInstance(Object oldInstance, Schema schema);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>